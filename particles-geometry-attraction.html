<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - geometry attractors particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0;
				padding: 0;
				overflow: hidden;
				background: #000000;
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
			}

			#info {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				padding: 20px;
				box-sizing: border-box;
				text-align: center;
				pointer-events: none;
				z-index: 100;
			}

			#info a {
				color: #ffffff;
				text-decoration: none;
			}

			#info .title-wrapper {
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 10px;
				margin-bottom: 10px;
			}

			#info .title-wrapper > a {
				font-size: 24px;
				font-weight: bold;
			}

			#info .title-wrapper > span {
				font-size: 18px;
				color: #888;
			}

			#info small {
				display: block;
				color: #888;
				font-size: 14px;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Geometry Attractors Particles</span>
			</div>

			<small>
				Particles attract to and orbit around geometry surface.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.168.0/build/three.module.js",
					"three/webgpu": "https://unpkg.com/three@0.168.0/build/three.webgpu.js",
					"three/tsl": "https://unpkg.com/three@0.168.0/build/three.tsl.js",
					"three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { float, If, PI, color, cos, instanceIndex, Loop, mix, mod, sin, instancedArray, Fn, uint, uniform, uniformArray, hash, vec3, vec4 } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer, controls, updateCompute, geometryMesh, geometryVertices, geometryNormals;

			init();

			async function init() {

				try {

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 3, 5, 8 );

				scene = new THREE.Scene();

				// ambient light
				const ambientLight = new THREE.AmbientLight( '#ffffff', 0.5 );
				scene.add( ambientLight );

				// directional light
				const directionalLight = new THREE.DirectionalLight( '#ffffff', 1.5 );
				directionalLight.position.set( 4, 2, 0 );
				scene.add( directionalLight );

				// renderer
				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.setClearColor( '#000000' );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 0.1;
				controls.maxDistance = 50;

				window.addEventListener( 'resize', onWindowResize );

				// Create geometry for attraction
				// You can replace this with any Three.js geometry or load a model:
				// - THREE.BoxGeometry, THREE.SphereGeometry, THREE.TorusGeometry, etc.
				// - Or use GLTFLoader to load external models: 
				//   const loader = new GLTFLoader();
				//   const gltf = await loader.loadAsync('path/to/model.glb');
				//   const geometry = gltf.scene.children[0].geometry;
				const geometry = new THREE.TorusKnotGeometry( 1, 0.3, 128, 32 );
				
				// Optional: scale/transform the geometry
				// geometry.scale(2, 2, 2);
				
				// Create mesh to visualize the geometry
				const geometryMaterial = new THREE.MeshStandardMaterial( { 
					color: '#ffffff', 
					wireframe: true,
					transparent: true,
					opacity: 0.3
				} );
				geometryMesh = new THREE.Mesh( geometry, geometryMaterial );
				scene.add( geometryMesh );

				// Extract vertices and normals from geometry
				const positionAttribute = geometry.attributes.position;
				const normalAttribute = geometry.attributes.normal;
				const vertexCount = positionAttribute.count;

				geometryVertices = uniformArray( [] );
				geometryNormals = uniformArray( [] );

				// Sample vertices from the geometry (we'll use a subset for performance)
				const maxSamples = 500;
				const sampleStep = Math.max( 1, Math.floor( vertexCount / maxSamples ) ); // Sample up to 500 vertices
				const sampledVertices = [];
				const sampledNormals = [];

				for ( let i = 0; i < vertexCount; i += sampleStep ) {
					if ( sampledVertices.length >= maxSamples ) break;
					
					const x = positionAttribute.getX( i );
					const y = positionAttribute.getY( i );
					const z = positionAttribute.getZ( i );
					sampledVertices.push( new THREE.Vector3( x, y, z ) );

					const nx = normalAttribute.getX( i );
					const ny = normalAttribute.getY( i );
					const nz = normalAttribute.getZ( i );
					sampledNormals.push( new THREE.Vector3( nx, ny, nz ) );
				}

				console.log( 'Sampled', sampledVertices.length, 'vertices from geometry' );

				geometryVertices.array = sampledVertices;
				geometryNormals.array = sampledNormals;
				const geometryVertexCount = uniform( sampledVertices.length, 'uint' );

				// particles
				const count = Math.pow( 2, 18 );
				const material = new THREE.SpriteNodeMaterial( { blending: THREE.AdditiveBlending, depthWrite: false } );

				const geometryMass = uniform( Number( `1e${7}` ) );
				const particleGlobalMass = uniform( Number( `1e${4}` ) );
				const timeScale = uniform( 1 );
				const spinningStrength = uniform( 2.75 );
				const maxSpeed = uniform( 8 );
				const gravityConstant = 6.67e-11;
				const velocityDamping = uniform( 0.1 );
				const scale = uniform( 0.008 );
				const boundHalfExtent = uniform( 8 );
				const colorA = uniform( color( '#5900ff' ) );
				const colorB = uniform( color( '#ffa575' ) );
				const attractionStrength = uniform( 1.0 );
				const surfaceDistance = uniform( 0.5 ); // Preferred distance from surface

				const positionBuffer = instancedArray( count, 'vec3' );
				const velocityBuffer = instancedArray( count, 'vec3' );

				const sphericalToVec3 = Fn( ( [ phi, theta ] ) => {

					const sinPhiRadius = sin( phi );

					return vec3(
						sinPhiRadius.mul( sin( theta ) ),
						cos( phi ),
						sinPhiRadius.mul( cos( theta ) )
					);

				} );

				// init compute
				const init = Fn( () => {

					const position = positionBuffer.element( instanceIndex );
					const velocity = velocityBuffer.element( instanceIndex );

					// Initialize particles in a sphere around the geometry
					// Use deterministic hash based on instanceIndex instead of Math.random()
					const seed1 = hash( instanceIndex.mul( uint( 7919 ) ) );
					const seed2 = hash( instanceIndex.mul( uint( 7829 ) ) );
					const seed3 = hash( instanceIndex.mul( uint( 7541 ) ) );
					
					const phi = seed1.mul( PI ).mul( 2 );
					const theta = seed2.mul( PI );
					const radius = seed3.mul( 3 ).add( 2 );
					const basePosition = sphericalToVec3( phi, theta ).mul( radius );
					position.assign( basePosition );

					const seed4 = hash( instanceIndex.mul( uint( 7127 ) ) );
					const seed5 = hash( instanceIndex.mul( uint( 6947 ) ) );
					const phiVel = seed4.mul( PI ).mul( 2 );
					const thetaVel = seed5.mul( PI );
					const baseVelocity = sphericalToVec3( phiVel, thetaVel ).mul( 0.05 );
					velocity.assign( baseVelocity );

				} );

				const initCompute = init().compute( count );

				const reset = () => {

					renderer.compute( initCompute );

				};

				reset();

				// update compute
				const update = Fn( () => {
					
					const particleMassMultiplier = hash( instanceIndex.mul( uint( 8677 ) ) ).remap( 0.25, 1 ).toVar();
					const particleMass = particleMassMultiplier.mul( particleGlobalMass ).toVar();

					const delta = float( 1 / 60 ).mul( timeScale ).toVar();
					const position = positionBuffer.element( instanceIndex );
					const velocity = velocityBuffer.element( instanceIndex );

						// Find closest point on geometry surface using brute force search
					// In production, you'd want to use a spatial acceleration structure
					let closestDistance = float( 1e10 ).toVar();
					let closestPoint = vec3( 0 ).toVar();
					let closestNormal = vec3( 0, 1, 0 ).toVar();

					Loop( geometryVertexCount, ( { i } ) => {

						const vertexPosition = geometryVertices.element( i );
						const toVertex = position.sub( vertexPosition );
						const dist = toVertex.length();

						If( dist.lessThan( closestDistance ), () => {

							closestDistance.assign( dist );
							closestPoint.assign( vertexPosition );
							closestNormal.assign( geometryNormals.element( i ) );

						} );

					} );

					// Calculate force towards geometry surface
					const toSurface = closestPoint.sub( position );
					const distanceToSurface = toSurface.length();
					const safeDistance = distanceToSurface.max( float( 0.001 ) ); // Prevent division by zero
					const directionToSurface = toSurface.div( safeDistance );

					// Attraction force based on distance from preferred surface distance
					const distanceFromPreferred = safeDistance.sub( surfaceDistance );
					const forceMagnitude = distanceFromPreferred.mul( attractionStrength ).mul( geometryMass ).mul( particleMass ).mul( gravityConstant ).div( safeDistance.pow( 2 ) );
					const attractionForce = directionToSurface.mul( forceMagnitude );
					
					// Apply attraction force
					velocity.addAssign( attractionForce.mul( delta ) );

					// Tangential force for orbital motion around the surface
					const tangent = directionToSurface.cross( closestNormal );
					const tangentLength = tangent.length();
					If( tangentLength.greaterThan( float( 0.001 ) ), () => {

						const normalizedTangent = tangent.div( tangentLength );
						const tangentialForce = normalizedTangent.mul( forceMagnitude ).mul( spinningStrength );
						velocity.addAssign( tangentialForce.mul( delta ) );

					} );

					// velocity clamping and damping
					const speed = velocity.length();
					If( speed.greaterThan( maxSpeed ), () => {

						velocity.assign( velocity.normalize().mul( maxSpeed ) );

					} );
					velocity.mulAssign( velocityDamping.oneMinus() );

					// position update
					position.addAssign( velocity.mul( delta ) );

					// box loop (optional - keeps particles in bounds)
					const halfHalfExtent = boundHalfExtent.div( 2 ).toVar();
					position.assign( mod( position.add( halfHalfExtent ), boundHalfExtent ).sub( halfHalfExtent ) );

				} );
				updateCompute = update().compute( count ).setName( 'Update Particles' );

				// nodes
				material.positionNode = positionBuffer.toAttribute();

				material.colorNode = Fn( () => {

					const velocity = velocityBuffer.toAttribute();
					const speed = velocity.length();
					const colorMix = speed.div( maxSpeed ).smoothstep( 0, 0.5 );
					const finalColor = mix( colorA, colorB, colorMix );

					return vec4( finalColor, 1 );

				} )();

				// Scale node with variation per particle
				material.scaleNode = Fn( () => {
					const particleScale = hash( instanceIndex.mul( uint( 8677 ) ) ).remap( 0.5, 1.0 );
					return scale.mul( particleScale );
				} )();

				// mesh
				const particleGeometry = new THREE.PlaneGeometry( 1, 1 );
				const mesh = new THREE.InstancedMesh( particleGeometry, material, count );
				scene.add( mesh );

				// debug
				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui.add( { geometryMassExponent: geometryMass.value.toString().length - 1 }, 'geometryMassExponent', 1, 10, 1 ).onChange( value => geometryMass.value = Number( `1e${value}` ) );
				gui.add( { particleGlobalMassExponent: particleGlobalMass.value.toString().length - 1 }, 'particleGlobalMassExponent', 1, 10, 1 ).onChange( value => particleGlobalMass.value = Number( `1e${value}` ) );
				gui.add( maxSpeed, 'value', 0, 10, 0.01 ).name( 'maxSpeed' );
				gui.add( velocityDamping, 'value', 0, 0.1, 0.001 ).name( 'velocityDamping' );
				gui.add( spinningStrength, 'value', 0, 10, 0.01 ).name( 'spinningStrength' );
				gui.add( scale, 'value', 0, 0.1, 0.001 ).name( 'scale' );
				gui.add( boundHalfExtent, 'value', 0, 20, 0.01 ).name( 'boundHalfExtent' );
				gui.add( attractionStrength, 'value', 0, 10, 0.01 ).name( 'attractionStrength' );
				gui.add( surfaceDistance, 'value', 0, 2, 0.01 ).name( 'surfaceDistance' );
				gui.addColor( { color: colorA.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorA' ).onChange( value => colorA.value.set( value ) );
				gui.addColor( { color: colorB.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorB' ).onChange( value => colorB.value.set( value ) );
				
				gui.add( { wireframe: geometryMaterial.wireframe }, 'wireframe' ).onChange( value => {
					geometryMaterial.wireframe = value;
				} );
				
				gui.add( { reset }, 'reset' );

				} catch ( error ) {

					console.error( 'Error initializing:', error );
					document.body.innerHTML += '<div style="color: white; padding: 20px;">Error: ' + error.message + '</div>';

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate() {

				controls.update();

				renderer.compute( updateCompute );
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>

